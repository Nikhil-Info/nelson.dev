---
title: Tests End-to-End avec Better Auth
date: '2025-09-17T07:01:11.746Z'
modifiedTime: '2025-09-17T07:01:11.746Z'
summary: Apprenez à configurer des tests end-to-end avec Better Auth.
---

## TL;DR

Vous devrez générer un jeton de session valide et le stocker sous forme de cookies. Cela permet à vos tests E2E d'accéder aux routes authentifiées sans connexion manuelle. Cette méthode fonctionne à la fois pour l'authentification par identifiants et OAuth.

> Dépôt GitHub : [nelsonlaidev/e2e-testing-with-better-auth](https://github.com/nelsonlaidev/e2e-testing-with-better-auth)

## Préface

Dans ce guide, nous utiliserons [Playwright](https://playwright.dev/) comme framework de test E2E, mais les concepts peuvent être appliqués à d'autres frameworks comme [Cypress](https://www.cypress.io/).

Pour plus de simplicité, nous utiliserons un exemple d'authentification par identifiants. Cependant, les mêmes principes s'appliquent aux fournisseurs OAuth.

De plus, nous utilisons une base de données SQLite à des fins de démonstration. Ajustez les interactions avec la base de données **(par exemple, noms de tables, types de colonnes)** selon votre configuration.

## Génération d'un jeton de session

Pour simuler une session authentifiée, nous devrons générer un jeton de session signé en utilisant `BETTER_AUTH_SECRET`. Ce jeton sera utilisé dans les cookies de session.

```ts
import crypto from 'node:crypto'

export const TEST_USER = {
  name: 'Utilisateur Test',
  email: 'test@example.com',
  sessionToken: '00000000000000000000000000000000',
  accountId: '000'
}

const signature = crypto
  .createHmac('sha256', process.env.BETTER_AUTH_SECRET!)
  .update(TEST_USER.sessionToken)
  .digest('base64')
const signedValue = `${TEST_USER.sessionToken}.${signature}`
```

## Insertion des données de test

Nous voulons garder notre utilisateur de test statique pour éviter de créer plusieurs utilisateurs pendant les tests. Insérez un utilisateur de test, un compte et une session dans la base de données s'ils n'existent pas déjà. Nous utilisons `0` comme ID unique pour toutes les clés primaires par souci de simplicité.

```ts
import { db } from '@/lib/db'

const TEST_UNIQUE_ID = '0'

const now = new Date().getTime()
const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).getTime() // 7 jours

const transaction = db.transaction(() => {
  db.prepare(
    `
      INSERT OR IGNORE INTO user (
        id, name, email, emailVerified, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?)
    `
  ).run(TEST_UNIQUE_ID, TEST_USER.name, TEST_USER.email, 0, now, now)

  db.prepare(
    `
      INSERT OR IGNORE INTO account (
        id, accountId, providerId, userId, password, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `
  ).run(TEST_UNIQUE_ID, TEST_USER.accountId, 'credential', TEST_UNIQUE_ID, 'password_hash', now, now)

  db.prepare(
    `
      INSERT INTO session (
        id, token, userId, expiresAt, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?)
      ON CONFLICT(token) DO UPDATE SET
      expiresAt = excluded.expiresAt,
      updatedAt = excluded.updatedAt
    `
  ).run(TEST_UNIQUE_ID, TEST_USER.sessionToken, TEST_UNIQUE_ID, expiresAt, now, now)
})

transaction()
```

## Stockage de la session

Enregistrez le jeton signé en tant que cookie dans un fichier JSON pour une utilisation dans les frameworks de test. N'oubliez pas d'encoder la valeur du cookie avec `encodeURIComponent{:.entity.name.function}`.

```ts
import fs from 'node:fs/promises'

const cookieObject = {
  name: 'better-auth.session_token',
  value: encodeURIComponent(signedValue), // [!code highlight]
  domain: 'localhost',
  path: '/',
  httpOnly: true,
  secure: false,
  sameSite: 'Lax',
  expires: Math.round(expiresAt / 1000)
}

await fs.writeFile('.auth/auth.json', JSON.stringify({ cookies: [cookieObject], origins: [] }, null, 2))
```

## Utilisation de la session dans les tests

Chargez la session stockée dans vos tests E2E pour accéder aux routes protégées sans vous connecter. L'exemple ci-dessous utilise Playwright, mais cela peut être adapté à toute bibliothèque de test (par exemple, Cypress) qui prend en charge l'injection de cookies.

```ts title='playwright.config.ts'
export default defineConfig({
  // ...
  projects: [
    { name: 'setup', testMatch: /global\.setup\.ts/, teardown: 'teardown' }, // [!code highlight]

    { name: 'teardown', testMatch: /global\.teardown\.ts/ }, // [!code highlight]

    {
      name: 'chromium',
      use: {
        ...devices['Desktop Chrome'],
        storageState: '.auth/auth.json' // [!code highlight]
      },
      dependencies: ['setup'] // [!code highlight]
    }
  ]
})
```

## Liens utiles

- [Configuration et nettoyage Playwright](https://playwright.dev/docs/test-global-setup-teardown)
- [État de stockage Playwright](https://playwright.dev/docs/auth#reuse-authentication-in-other-scenarios)
- [Crochets Cypress](https://docs.cypress.io/app/core-concepts/writing-and-organizing-tests#Hooks)
- [Définir un cookie Cypress](https://docs.cypress.io/api/commands/setcookie)