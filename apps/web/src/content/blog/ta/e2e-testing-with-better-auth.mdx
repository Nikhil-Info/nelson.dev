---
title: Better Auth உடன் End-to-End சோதனை
date: '2025-09-17T07:01:11.746Z'
modifiedTime: '2025-09-17T07:01:11.746Z'
summary: Better Auth உடன் End-to-End சோதனையை எவ்வாறு அமைப்பது என்பதைக் கற்றுக்கொள்ளுங்கள்.
---

## TL;DR

நீங்கள் ஒரு செல்லுபடியாகும் அமர்வு டோக்கனை உருவாக்கி குக்கீகளாக சேமிக்க வேண்டும். இது உங்கள் E2E சோதனைகளுக்கு கைமுறையாக உள்நுழையாமல் அங்கீகரிக்கப்பட்ட வழிகளுக்கு அணுகலை அனுமதிக்கிறது. இந்த முறை சான்றுகள்-அடிப்படையிலான மற்றும் OAuth அங்கீகாரம் இரண்டிற்கும் வேலை செய்கிறது.

> GitHub களஞ்சியம்: [nelsonlaidev/e2e-testing-with-better-auth](https://github.com/nelsonlaidev/e2e-testing-with-better-auth)

## முன்னுரை

இந்த வழிகாட்டியில், நாங்கள் எங்கள் E2E சோதனை கட்டமைப்பாக [Playwright](https://playwright.dev/) பயன்படுத்துவோம், ஆனால் இந்த கருத்துகள் [Cypress](https://www.cypress.io/) போன்ற பிற கட்டமைப்புகளுக்கும் பயன்படுத்தப்படலாம்.

எளிமைக்காக, நாங்கள் ஒரு சான்றுகள்-அடிப்படையிலான அங்கீகார உதாரணத்தைப் பயன்படுத்துவோம். இருப்பினும், OAuth வழங்குநர்களுக்கும் அதே கொள்கைகள் பொருந்தும்.

மேலும், நாங்கள் ஆர்ப்பாட்ட நோக்கங்களுக்காக SQLite தரவுத்தளத்தைப் பயன்படுத்துகிறோம். உங்கள் அமைப்பிற்கு ஏற்ப தரவுத்தள தொடர்புகளை **(எ.கா., அட்டவணை பெயர்கள், நெடுவரிசை வகைகள்)** சரிசெய்யவும்.

## அமர்வு டோக்கன் உருவாக்குதல்

அங்கீகரிக்கப்பட்ட அமர்வை உருவகப்படுத்த, நாம் `BETTER_AUTH_SECRET` பயன்படுத்தி ஒரு கையொப்பமிடப்பட்ட அமர்வு டோக்கனை உருவாக்க வேண்டும். இந்த டோக்கன் அமர்வு குக்கீகளில் பயன்படுத்தப்படும்.

```ts
import crypto from 'node:crypto'

export const TEST_USER = {
  name: 'சோதனை பயனர்',
  email: 'test@example.com',
  sessionToken: '00000000000000000000000000000000',
  accountId: '000'
}

const signature = crypto
  .createHmac('sha256', process.env.BETTER_AUTH_SECRET!)
  .update(TEST_USER.sessionToken)
  .digest('base64')
const signedValue = `${TEST_USER.sessionToken}.${signature}`
```

## சோதனை தரவைச் செருகுதல்

சோதனைகளின் போது பல பயனர்களை உருவாக்குவதைத் தவிர்க்க, எங்கள் சோதனை பயனரை நிலையானதாக வைத்திருக்க விரும்புகிறோம். ஏற்கனவே இல்லையென்றால், ஒரு சோதனை பயனர், கணக்கு மற்றும் அமர்வை தரவுத்தளத்தில் செருகவும். எளிமைக்காக அனைத்து முதன்மை விசைகளுக்கும் `0` ஐ தனிப்பட்ட ID ஆகப் பயன்படுத்துகிறோம்.

```ts
import { db } from '@/lib/db'

const TEST_UNIQUE_ID = '0'

const now = new Date().getTime()
const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).getTime() // 7 நாட்கள்

const transaction = db.transaction(() => {
  db.prepare(
    `
      INSERT OR IGNORE INTO user (
        id, name, email, emailVerified, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?)
    `
  ).run(TEST_UNIQUE_ID, TEST_USER.name, TEST_USER.email, 0, now, now)

  db.prepare(
    `
      INSERT OR IGNORE INTO account (
        id, accountId, providerId, userId, password, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?)
    `
  ).run(TEST_UNIQUE_ID, TEST_USER.accountId, 'credential', TEST_UNIQUE_ID, 'password_hash', now, now)

  db.prepare(
    `
      INSERT INTO session (
        id, token, userId, expiresAt, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?)
      ON CONFLICT(token) DO UPDATE SET
      expiresAt = excluded.expiresAt,
      updatedAt = excluded.updatedAt
    `
  ).run(TEST_UNIQUE_ID, TEST_USER.sessionToken, TEST_UNIQUE_ID, expiresAt, now, now)
})

transaction()
```

## அமர்வைச் சேமித்தல்

சோதனை கட்டமைப்புகளில் பயன்படுத்த கையொப்பமிடப்பட்ட டோக்கனை ஒரு JSON கோப்பில் குக்கீயாக சேமிக்கவும். குக்கீ மதிப்பை `encodeURIComponent{:.entity.name.function}` உடன் குறியாக்கம் செய்வதை மறக்காதீர்கள்.

```ts
import fs from 'node:fs/promises'

const cookieObject = {
  name: 'better-auth.session_token',
  value: encodeURIComponent(signedValue), // [!code highlight]
  domain: 'localhost',
  path: '/',
  httpOnly: true,
  secure: false,
  sameSite: 'Lax',
  expires: Math.round(expiresAt / 1000)
}

await fs.writeFile('.auth/auth.json', JSON.stringify({ cookies: [cookieObject], origins: [] }, null, 2))
```

## சோதனைகளில் அமர்வைப் பயன்படுத்துதல்

உள்நுழையாமலேயே பாதுகாக்கப்பட்ட வழிகளுக்கு அணுக, உங்கள் E2E சோதனைகளில் சேமிக்கப்பட்ட அமர்வை ஏற்றவும். கீழே உள்ள உதாரணம் Playwright ஐப் பயன்படுத்துகிறது, ஆனால் இது குக்கீ ஊசி போடலை ஆதரிக்கும் எந்த சோதனை நூலகத்திற்கும் (எ.கா., Cypress) பொருந்தும்.

```ts title='playwright.config.ts'
export default defineConfig({
  // ...
  projects: [
    { name: 'setup', testMatch: /global\.setup\.ts/, teardown: 'teardown' }, // [!code highlight]

    { name: 'teardown', testMatch: /global\.teardown\.ts/ }, // [!code highlight]

    {
      name: 'chromium',
      use: {
        ...devices['Desktop Chrome'],
        storageState: '.auth/auth.json' // [!code highlight]
      },
      dependencies: ['setup'] // [!code highlight]
    }
  ]
})
```

## பயனுள்ள இணைப்புகள்

- [Playwright அமைப்பு மற்றும் கலைப்பு](https://playwright.dev/docs/test-global-setup-teardown)
- [Playwright சேமிப்பு நிலை](https://playwright.dev/docs/auth#reuse-authentication-in-other-scenarios)
- [Cypress கொக்கிகள்](https://docs.cypress.io/app/core-concepts/writing-and-organizing-tests#Hooks)
- [Cypress குக்கீ அமை](https://docs.cypress.io/api/commands/setcookie)